(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.immer = {}));
}(this, (function (exports) { 'use strict';

	var _ref;

	// Should be no imports here!
	// Some things that should be evaluated before all else...
	// We only want to know if non-polyfilled symbols are available
	var hasSymbol = typeof Symbol !== "undefined" && typeof
	/*#__PURE__*/
	Symbol("x") === "symbol";
	var hasMap = typeof Map !== "undefined";
	var hasSet = typeof Set !== "undefined";
	var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
	/**
	 * The sentinel value returned by producers to replace the draft with undefined.
	 */

	var NOTHING = hasSymbol ?
	/*#__PURE__*/
	Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
	/**
	 * To let Immer treat your class instances as plain immutable objects
	 * (albeit with a custom prototype), you must define either an instance property
	 * or a static property on each of your custom classes.
	 *
	 * Otherwise, your class instance will never be drafted, which means it won't be
	 * safe to mutate in a produce callback.
	 */

	var DRAFTABLE = hasSymbol ?
	/*#__PURE__*/
	Symbol.for("immer-draftable") : "__$immer_draftable";
	var DRAFT_STATE = hasSymbol ?
	/*#__PURE__*/
	Symbol.for("immer-state") : "__$immer_state"; // Even a polyfilled Symbol might provide Symbol.iterator

	var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";

	var errors = {
	  0: "Illegal state",
	  1: "Immer drafts cannot have computed properties",
	  2: "This object has been frozen and should not be mutated",
	  3: functi